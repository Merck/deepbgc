import pandas as pd
import hashlib
import numpy as np
from deepbgc.pipeline import DeepBGCModel

SCORE_COLUMN = 'deepbgc_score'


class DeepBGCDetector:
    def __init__(self, model):
        if isinstance(model, str):
            print('Reading model from path: ', model)
            model = DeepBGCModel.load(model)
        self.model = model

    def predict_domain_bgc_score(self, domains):
        """
        Get BGC score score for given Domain DataFrame, add it as SCORE_COLUMN column.
        :param domains: Domain DataFrame, multiple samples marked by different 'sequence_id' will be predicted separately
        :return: Original Domain DataFrame with SCORE_COLUMN column added.
        """

        samples = [group for i, group in domains.groupby('sequence_id')]
        scores = []
        for sample in samples:
            score = sample.copy()
            score[SCORE_COLUMN] = self.model.predict(sample)
            scores.append(score)

        merged = pd.concat(scores)  # type: pd.DataFrame
        return merged

    def detect(self, domains, score_threshold=0.5):
        if 'sequence_id' in domains.columns:
            sequences = domains.groupby('sequence_id')
            print('Detecting in {} sequences: {}'.format(len(sequences), domains['sequence_id'].unique()))
        else:
            sequences = [(None, domains)]
            print('Detecting in single sequence...')

        all_candidates = []
        for sequence_id, sequence_domains in sequences:
            scores = self.predict_domain_bgc_score(domains)
            candidates = threshold_sequence_candidates(scores, score_threshold, merge_max_protein_gap=0, merge_max_nucl_gap=0)
            if sequence_id:
                candidates.insert(0, 'sequence_id', sequence_id)
            all_candidates.append(candidates)
        return pd.concat(all_candidates)


def agg_concat(s):
    """
    Join given list with semicolons
    :param s: list of objects to join
    :return: joined string
    """
    return ';'.join(s)


def average_protein_score(domains, concat_domains=True):
    """
    Average scores into a SCORE_COLUMN column by protein using the 'protein_id' and other PROTEIN_GROUP_COLS.
    :param domains: DataFrame from the Domain CSV file
    :param concat_domains: Whether to include a ';'-concatenated list of pfam_ids for each protein.
    :return: DataFrame of proteins with averaged SCORE_COLUMN column
    """
    PROTEIN_GROUP_COLS = ['protein_id']
    PROTEIN_EXTRA_COLS = ['in_cluster', 'gene_start', 'gene_end', 'gene_strand']

    extra_cols = [col for col in PROTEIN_EXTRA_COLS if col in domains.columns]
    all_cols = extra_cols + PROTEIN_GROUP_COLS
    if concat_domains:
        all_cols.append('pfam_id')
    copy = domains[all_cols].copy()
    copy[SCORE_COLUMN] = domains[SCORE_COLUMN]
    per_gene = copy.groupby(all_cols, sort=False)
    if concat_domains:
        return per_gene.agg({'pfam_id': agg_concat, SCORE_COLUMN: 'mean'}) \
            .rename(columns={'pfam_id': 'pfam_ids'}) \
            .reset_index()
    else:
        return per_gene.mean().reset_index()


def get_candidate(start, end, pfam_ids, protein_ids, protein_scores):
    """
    Get single BGC candidate dictionary
    :param start: nucleotide coordinate start
    :param end: nucleotide coordinate end
    :param pfam_ids: list of pfam ids in candidate
    :param protein_ids: list of protein ids in candidate
    :param protein_scores: list of protein model score outputs
    :return: BGC candidate dictionary
    """
    return {
        'nucl_start': start,
        'nucl_end': end,
        'num_proteins': len(protein_ids),
        'num_domains': len(pfam_ids),
        'protein_ids': ';'.join(protein_ids),
        'pfam_ids': ';'.join(pfam_ids),
        SCORE_COLUMN: np.mean(protein_scores)
    }


def threshold_sequence_candidates(domain_scores, threshold, merge_max_protein_gap=0, merge_max_nucl_gap=0):
    """
    Get a BGC candidate DataFrame for domain scores in a single contig.
    Generated by averaging domain scores by protein and then merging consecutive proteins with score satisfying given threshold
    :param domain_scores: DataFrame of domains and their SCORE_COLUMN column
    :param threshold: Averaged protein score threshold (inclusive) used to include or discard BGC proteins
    :param merge_max_protein_gap: Merge candidates with given (or smaller) number of non-BGC proteins between them
    :param merge_max_nucl_gap: Merge candidates with given (or smaller) number of nucleotides between them
    :return: DataFrame of BGC candidates
    """

    protein_scores = average_protein_score(domain_scores, concat_domains=True)

    candidates = []
    candidate_start = None
    candidate_end = None
    candidate_domains = []
    candidate_proteins = []
    candidate_scores = []
    gap_domains = []
    gap_proteins = []
    gap_scores = []
    for i, protein in protein_scores.iterrows():
        score = protein[SCORE_COLUMN]
        # Inactive protein, add to gap
        if score < threshold:
            gap_proteins.append(protein['protein_id'])
            gap_domains += protein['pfam_ids'].split(';')
            gap_scores.append(score)
            # We just changed from active to inactive, add previous region as candidate
            if candidate_start is not None:
                candidates.append((candidate_start, candidate_end, candidate_domains, candidate_proteins, candidate_scores))
                candidate_start = None
                candidate_end = None
                candidate_domains = []
                candidate_proteins = []
                candidate_scores = []
        # Active protein
        else:
            if not candidate_start:
                candidate_start = protein['gene_start']
                if candidates:
                    # Check if we should merge with the previous candidate
                    prev_start, prev_end, prev_domains, prev_proteins, prev_scores = candidates[-1]
                    if len(gap_proteins) <= merge_max_protein_gap or (candidate_start - prev_end) <= merge_max_nucl_gap:
                        # Remove previous candidate and continue where it started
                        candidates = candidates[:-1]
                        candidate_start = prev_start
                        candidate_domains = prev_domains + gap_domains
                        candidate_proteins = prev_proteins + gap_proteins
                        candidate_scores = prev_scores + gap_scores

            candidate_end = protein['gene_end']
            candidate_proteins.append(protein['protein_id'])
            candidate_domains += protein['pfam_ids'].split(';')
            candidate_scores.append(score)
            gap_domains = []
            gap_proteins = []
            gap_scores = []

    # Last protein was active, add previous region as candidate
    if candidate_start is not None:
        candidates.append((candidate_start, candidate_end, candidate_domains, candidate_proteins, candidate_scores))

    cands = pd.DataFrame([get_candidate(*args) for args in candidates])
    if cands.empty:
        return cands

    cands['nucl_start'] = cands['nucl_start'].astype('int64')
    cands['nucl_end'] = cands['nucl_end'].astype('int64')
    cands['nucl_length'] = cands['nucl_end'] - cands['nucl_start'] + 1
    cands['candidate_hash'] = cands['pfam_ids'].apply(
        lambda pfam_ids: hashlib.md5(pfam_ids.encode('utf-8')).hexdigest())
    cands = cands[['candidate_hash', SCORE_COLUMN, 'nucl_length', 'nucl_start', 'nucl_end',
         'num_domains', 'num_proteins', 'protein_ids', 'pfam_ids']]
    return cands
